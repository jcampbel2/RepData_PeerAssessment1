## this is deliberate limitation of function for simplification as all that is required by project
if (length(MatA)!=length(MatB) ) {
message("ERROR - Matrix's are different sizes")
flag <- FALSE
}
if ( length(dim(MatA)) != 2  ) {
message("ERROR - Matrix A is not 2 dimensional")
flag <- FALSE
}
if ( length(dim(MatB)) != 2  ) {
message("ERROR - Matrix B is not 2 dimensional")
flag <- FALSE
}
if (dim(MatA)[1]!=dim(MatA)[2]   ) {
message("ERROR - Matrix A is not square")
flag <- FALSE
}
if (dim(MatB)[1]!=dim(MatB)[2]   ) {
message("ERROR - Matrix B is not square")
flag <- FALSE
}
if (flag) {
MatAB <- round(MatA %*% MatB,digit=5)   ##remove decimal rounding issues
MatBA <- round(MatB %*% MatA,digit=5)
MatI <- MatAB == MatBA
## check 1, AB==BA
if (sum(MatI)==length(MatI)) {
## check 2 that either MAtAB or MatBA is identity matrix
## we already know that matrix's are both same dim and square
if (sum(MatAB)==length(MatAB[1,])) {
retval=TRUE
}
}
}
retval
}
##  Function to test that object passed is a square matrix and so valid for inversion
TestMatrix <- function(x) {
##set default return value
##Initial test that correctly formated matrix, if not reset x to NULL
if (  ( (is.matrix(x)) && (length(dim(x)) == 2) && ( dim(x)[1]==dim(x)[2]) )  ) {
retVal <- TRUE
}
else (retVal=FALSE)
retVal
}
test5 <- makeCacheMatrix(t5)
test5$getInverse()
cacheSolve(test5)
## Function create a list with 4 elements in it
## each element is a function
## The object returned by the function also hold 2 varibles which as scoped
## to each instance of the object only these are x and InvMat. Both are matrix
## this means that multiple list objects which are created by makeCacheMatrix have
## their own copies of x and InvMat and the values of these persist so long as
## the parent list does
##
## functions
## getMatrix returns the current value of the main matrix held in var x
## setMatrix overides the value of the main matrix x with a new one (passed as a parameter)
## and resets MatInv to NULL
## getInverse returns the inverse matrix MatInv
## setInverse sets the inverse matrix MatInv
makeCacheMatrix <- function(x = matrix(), ... ) {
if (TestMatrix(x)) {
message("Matrix set successfully")
} else {
x <- NULL
message("Error - object must be a 2 Dim Matrix with number rows = number columns")
}
InvMat <- NULL
setMatrix <- function(y) {
## Error handle here to check if x is matrix and square?
if (TestMatrix(y)) {
x <<- y
InvMat <<- NULL ##reset inverse matrix
message("Matrix set successfully")
}
else {
message("Error - object must be a 2 Dim Matrix with number rows = number columns")
message("Original Matrix NOT reset")
}
}
getMatrix <- function() x
getInverse <- function() {
if (is.null(InvMat)){
message("Inverse not stored yet, call cacheSolve function to get Inverse matrix")
}
InvMat
}
setInverse <- function(mm) {
##check matrix passed is inverse of x
if (TestInverse(mm,x))  {
InvMat <<- mm
} else {
message("Matrix passed is not valid to be set as Inverse")
}
}
list(getMatrix=getMatrix,setMatrix=setMatrix,getInverse=getInverse,setInverse=setInverse)
}
## Write a short comment describing this function
## This function accepts a list object as created by function makeCacheMatrix above
## It returns the inverse of the matrix held in that object
##
## It initially checks if the inverse matrix is already stored in x by use of function getInverse
## If that isnt null this is returned as inverse matrix
## If it hasnt already been calculated then it calculates the inverse using "solve"
## and then stores it back into object x using the function setInverse
##should function be passed object with functions or just matrix??
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
MatTemp <- x$getInverse()
print(MatTemp)
if (!is.null(MatTemp)) {
message ("getting cached data")
} else {
message ("calculating Inverse Matrix and storing ...")
MatTemp <- solve(x$getMatrix())
x$setInverse(MatTemp)
message ("Inverse stored on object")
}
MatTemp
}
##  To be used to validate function makeCacheMatrix and cacheSolve
##  function to test solution works by use of test AB=BA=I
##  where  A is a matrix and B its inverse and I is an identity matrix of same size
##  round to integer for ease of checking
#  creates logical matrix I = (AB == BA),
## check sum(I)=length(I), (in R TRUE =1 and FALSE=0)
TestInverse <- function(MatA,MatB) {
retval=FALSE
flag = TRUE
## need initial test that matrix MatA and MatB are both 2 dimensions and square
## this is deliberate limitation of function for simplification as all that is required by project
if (length(MatA)!=length(MatB) ) {
message("ERROR - Matrix's are different sizes")
flag <- FALSE
}
if ( length(dim(MatA)) != 2  ) {
message("ERROR - Matrix A is not 2 dimensional")
flag <- FALSE
}
if ( length(dim(MatB)) != 2  ) {
message("ERROR - Matrix B is not 2 dimensional")
flag <- FALSE
}
if (dim(MatA)[1]!=dim(MatA)[2]   ) {
message("ERROR - Matrix A is not square")
flag <- FALSE
}
if (dim(MatB)[1]!=dim(MatB)[2]   ) {
message("ERROR - Matrix B is not square")
flag <- FALSE
}
if (flag) {
MatAB <- round(MatA %*% MatB,digit=5)   ##remove decimal rounding issues
MatBA <- round(MatB %*% MatA,digit=5)
MatI <- MatAB == MatBA
## check 1, AB==BA
if (sum(MatI)==length(MatI)) {
## check 2 that either MAtAB or MatBA is identity matrix
## we already know that matrix's are both same dim and square
if (sum(MatAB)==length(MatAB[1,])) {
retval=TRUE
}
}
}
retval
}
##  Function to test that object passed is a square matrix and so valid for inversion
TestMatrix <- function(x) {
##set default return value
##Initial test that correctly formated matrix, if not reset x to NULL
if (  ( (is.matrix(x)) && (length(dim(x)) == 2) && ( dim(x)[1]==dim(x)[2]) )  ) {
retVal <- TRUE
}
else (retVal=FALSE)
retVal
}
test5 <- makeCacheMatrix(t5)
cacheSolve(test5)
## Function create a list with 4 elements in it
## each element is a function
## The object returned by the function also hold 2 varibles which as scoped
## to each instance of the object only these are x and InvMat. Both are matrix
## this means that multiple list objects which are created by makeCacheMatrix have
## their own copies of x and InvMat and the values of these persist so long as
## the parent list does
##
## functions
## getMatrix returns the current value of the main matrix held in var x
## setMatrix overides the value of the main matrix x with a new one (passed as a parameter)
## and resets MatInv to NULL
## getInverse returns the inverse matrix MatInv
## setInverse sets the inverse matrix MatInv
makeCacheMatrix <- function(x = matrix(), ... ) {
if (TestMatrix(x)) {
message("Matrix set successfully")
} else {
x <- NULL
message("Error - object must be a 2 Dim Matrix with number rows = number columns")
}
InvMat <- NULL
setMatrix <- function(y) {
## Error handle here to check if x is matrix and square?
if (TestMatrix(y)) {
x <<- y
InvMat <<- NULL ##reset inverse matrix
message("Matrix set successfully")
}
else {
message("Error - object must be a 2 Dim Matrix with number rows = number columns")
message("Original Matrix NOT reset")
}
}
getMatrix <- function() x
getInverse <- function() {
if (is.null(InvMat)){
message("Inverse not stored yet, call cacheSolve function to get Inverse matrix")
}
InvMat
}
setInverse <- function(mm) {
##check matrix passed is inverse of x
if (TestInverse(mm,x))  {
InvMat <<- mm
message ("Inverse stored on object")
} else {
message("Matrix passed is not valid to be set as Inverse")
}
}
list(getMatrix=getMatrix,setMatrix=setMatrix,getInverse=getInverse,setInverse=setInverse)
}
## Write a short comment describing this function
## This function accepts a list object as created by function makeCacheMatrix above
## It returns the inverse of the matrix held in that object
##
## It initially checks if the inverse matrix is already stored in x by use of function getInverse
## If that isnt null this is returned as inverse matrix
## If it hasnt already been calculated then it calculates the inverse using "solve"
## and then stores it back into object x using the function setInverse
##should function be passed object with functions or just matrix??
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
MatTemp <- x$getInverse()
print(MatTemp)
if (!is.null(MatTemp)) {
message ("getting cached data")
} else {
message ("calculating Inverse Matrix and storing ...")
MatTemp <- solve(x$getMatrix())
x$setInverse(MatTemp)
}
MatTemp
}
##  To be used to validate function makeCacheMatrix and cacheSolve
##  function to test solution works by use of test AB=BA=I
##  where  A is a matrix and B its inverse and I is an identity matrix of same size
##  round to integer for ease of checking
#  creates logical matrix I = (AB == BA),
## check sum(I)=length(I), (in R TRUE =1 and FALSE=0)
TestInverse <- function(MatA,MatB) {
retval=FALSE
flag = TRUE
## need initial test that matrix MatA and MatB are both 2 dimensions and square
## this is deliberate limitation of function for simplification as all that is required by project
if (length(MatA)!=length(MatB) ) {
message("ERROR - Matrix's are different sizes")
flag <- FALSE
}
if ( length(dim(MatA)) != 2  ) {
message("ERROR - Matrix A is not 2 dimensional")
flag <- FALSE
}
if ( length(dim(MatB)) != 2  ) {
message("ERROR - Matrix B is not 2 dimensional")
flag <- FALSE
}
if (dim(MatA)[1]!=dim(MatA)[2]   ) {
message("ERROR - Matrix A is not square")
flag <- FALSE
}
if (dim(MatB)[1]!=dim(MatB)[2]   ) {
message("ERROR - Matrix B is not square")
flag <- FALSE
}
if (flag) {
MatAB <- round(MatA %*% MatB,digit=5)   ##remove decimal rounding issues
MatBA <- round(MatB %*% MatA,digit=5)
MatI <- MatAB == MatBA
## check 1, AB==BA
if (sum(MatI)==length(MatI)) {
## check 2 that either MAtAB or MatBA is identity matrix
## we already know that matrix's are both same dim and square
if (sum(MatAB)==length(MatAB[1,])) {
retval=TRUE
}
}
}
retval
}
##  Function to test that object passed is a square matrix and so valid for inversion
TestMatrix <- function(x) {
##set default return value
##Initial test that correctly formated matrix, if not reset x to NULL
if (  ( (is.matrix(x)) && (length(dim(x)) == 2) && ( dim(x)[1]==dim(x)[2]) )  ) {
retVal <- TRUE
}
else (retVal=FALSE)
retVal
}
test5 <- makeCacheMatrix(t5)
cacheSolve(test5)
test5$getInverse()
test5$setMatrix(t4)
test5$getInverse()
cacheSolve(test5)
test5$getInverse()
install.packages("RMySQL")
library("RMySQL")
library("MySQL")
install.packages(“RMySQL”, type = “source”)
install.packages("RMySQL")
install.packages("RMySQL", type="source")
install.packages("RMySQL")
install.packages("RMySQL")
?install.package
?install.packages
install.packages("RMySQL", type="source")
install.packages("RMySQL", type="source")
install.packages("RMySQL", type="source")
library("RMySQL")
DB <- dbConnect(MySQL(),user="genome",host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(DB,"show databases;")
result
dbDisconnect(ucscDb)
dbDisconnect(DB)
DB <- dbConnect(MySQL(),user="jcampbel2",host="localhost")
DB <- dbConnect(MySQL(),user="jcampbel2",host="localhost", password="53DixonAv")
qry <- dbSendQuery(DB,"select * from world.city")
res <- fetch(qry)
head(res)
dbDisconnect(DB)
?fetch
table(res)
rlen(res)
class(res)
length(res)
length(res[,1])
res[500,]
res[501,]
res[502,]
b <-fetch(qry)
dbClearResult(qry)
dbDisconnect(DB)
library(nlme)
library(lattice)
xyplot(weight ~ Time | Diet, BodyWeight)
a<-xyplot(weight ~ Time | Diet, BodyWeight)
object(a)
class(a)
?points()
?axis()
?lines()
?panel.lmline()
print(a)
?print.trellis()
?splom()
?trellis.par.set()
library(datasets)
data(airquality)
qplot(Wind, Ozone, data = airquality, facets = . ~ factor(Month))
install.packages("ggplot")
qplot(Wind, Ozone, data = airquality, facets = . ~ factor(Month))
?qplot()
install.packages("ggplot")
install.packages("ggplot2")
qplot(Wind, Ozone, data = airquality, facets = . ~ factor(Month))
library("ggplot2")
qplot(Wind, Ozone, data = airquality, facets = . ~ factor(Month))
qplot(Wind, Ozone, data = airquality)
qplot(Wind, Ozone, data = airquality, geom = "smooth")
airquality = transform(airquality, Month = factor(Month))
qplot(Wind, Ozone, data = airquality, facets = . ~ Month)
g <- ggplot(movies, aes(votes, rating))
print(g)
qplot(votes, rating, data = movies)
qplot(votes, rating, data = movies, smooth = "loess")
qplot(votes, rating, data = movies) + geom_smooth()
qplot(votes, rating, data = movies) + stats_smooth("loess")
qplot(votes, rating, data = movies, panel = panel.loess)
a <- data.frame(1:5,2:6)
a
colnames(a)
lab <- c("v1",v2)
lab <- c("v1","v2")
lab
class(lab)
class(a)
colnames(a) <- lab
colnames(a)
a
setwd("C:/Users/james_000/DataScPrj/RepResearch/Assign1/RepData_PeerAssessment1")
actdata <- read.csv("./data/activity.csv")
actdata$date <- as.POSIXct(actdata$date)
stepsbyday <- ddply(actdata[!is.na(actdata$steps),],.(date),
summarize,totsteps=sum(steps))
library("plyr")
library("knitr")
library("ggplot2")
stepsbyday <- ddply(actdata[!is.na(actdata$steps),],.(date),
summarize,totsteps=sum(steps))
p1 <- ggplot(stepsbyday,aes(totsteps, colour="red"))
p1 <- p1 +labs("Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
p1 <- p1 + geom_histogram()
p1
range(stepsbyday$totsteps)
p1 <- p1 + stat_bin(binwidth=1000)
p1
p1 <- p1 +labs("Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
p1 <- p1 + geom_histogram()
p1 <- p1 + stat_bin(binwidth=1000)
p1
p1 <- NULL
p1
p1 <- ggplot(stepsbyday,aes(totsteps, fill="red"))
p1 <- p1 +labs("Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
p1 <- p1 + stat_bin(binwidth=1000)
p1 <- p1 + geom_histogram()
p1
p1 <- ggplot(stepsbyday,aes(totsteps, fill="red"))
p1 <- p1 +labs("Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
##p1 <- p1 + stat_bin(binwidth=1000)
p1 <- p1 + stat_bin(breaks=seq(0,24000, by=1000)
p1 <- p1 + geom_histogram()
p1 <- ggplot(stepsbyday,aes(totsteps, fill="red"))
p1 <- p1 +labs("Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
##p1 <- p1 + stat_bin(binwidth=1000)
p1 <- p1 + stat_bin(breaks=seq(0,24000, by=1000) )
p1 <- p1 + geom_histogram()
p1
p1+stat_bin(breaks=seq(0,24000,by=1000))
p1+stat_bin(binwidth=1000)
?stat_bin
p1 <- ggplot(stepsbyday,aes(totsteps, fill="red"))
p1 <- p1 +labs(title="Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
p1+stat_bin()
p1+stat_bin("binwidth=1000")
p1+stat_bin("bin_width=1000")
p1+stat_bin(bin_width=1000)
p1+stat_bin(binwidth=1000)
p1+geom_histogram(binwidth=1000)
p1+geom_histogram(binwidth=10000)
p1+geom_histogram(binwidth=100)
p1+geom_histogram(binwidth=500)
p1+geom_histogram(binwidth=1000)
p1 <- ggplot(stepsbyday,aes(totsteps, fill="red"))
p1 <- p1 +labs(title="Histogram of Number of steps per day", y="Counts Days", x= "Total Steps in 1 day")
p1 <- p1 + geom_histogram(binwidth=1000)
p1
?xtable
install.packages("xtable")
library("xtable", lib.loc="C:/Users/james_000/Documents/R/win-library/3.0")
stepmean <- mean(stepsbyday$totsteps)
stepmedian <- median(stepsbyday$totsteps)
xtable(stepmean)
tab1 <- as.data.frame()
? as.data.frame()
tab1 <-as.data.frame(stepmean)
tab1
?rowname
rowname <- c("Mean","Median")
rowname
tab1 <-as.data.frame(c(stepmean,stepmedian), row.names=rowname)
tab1
tab1 <-as.data.frame(values=c(stepmean,stepmedian), row.names=rowname)
tab1 <-as.data.frame("values"=c(stepmean,stepmedian), row.names=rowname)
values=c(stepmean,stepmedian)
values
tab1 <-as.data.frame(values, row.names=rowname)
tab1
xtable(tab1)
?xtable
xtab1 <-xtable(tab1)
print(xtab1, type="html")
?print
?print
print(xtab1)
print(xtab1, type="text")
stepmean <- mean(stepsbyday$totsteps)
stepmedian <- median(stepsbyday$totsteps)
rowname <- c("Mean","Median")
xtab1 <-xtable(as.data.frame(c(stepmean,stepmedian), row.names=rowname) )
print(xtab1, type="html")
xtab1 <-xtable(as.data.frame(c(stepmean,stepmedian), row.names=rowname, col.names="Values") )
print(xtab1, type="html")
? as.data.frame
xtab1 <-xtable(as.data.frame(x=c(stepmean,stepmedian), row.names=rowname, col.names="Values") )
xtab1
xtab1 <-xtable(as.data.frame(x=Values=c(stepmean,stepmedian), row.names=rowname, col.names="Values") )
xtab1 <-xtable(as.data.frame(x=Values=c(stepmean,stepmedian), row.names=rowname, col.names="Values") )
xtab1 <-xtable(as.data.frame(x=Values <- c(stepmean,stepmedian), row.names=rowname, col.names="Values") )
xtab1
xtab1 <-xtable(as.data.frame(x={Values <- c(stepmean,stepmedian)}, row.names=rowname, col.names="Values") )
xtab1
as.data.frame(x={Values <- c(stepmean,stepmedian)}, row.names=rowname, col.names="Values")
as.data.frame(Values=c(stepmean,stepmedian), row.names=rowname, col.names="Values")
as.data.frame(Values=c(stepmean,stepmedian), x=Values, row.names=rowname, col.names="Values")
xtab1 <-xtable(as.data.frame(Values=c(stepmean,stepmedian),
x=Values, row.names=rowname,
col.names="Values") )
print(xtab1, type="html")
